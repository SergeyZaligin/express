<p>mocha -u tdd -R spec qa/tests-unit.js</p>
<h3>Request obj</h3>
<ol>
    <li>
        <h4>
            req.params
        </h4>
        <p>
            Массив, содержащий именованные параметры маршрутизации.
        </p>
    </li>
    <li>
        <h4>
            req.param(name)
        </h4>
        <p>
            Возвращает именованный параметр маршрутизации или параметры GET / POST . Я рекомендую избегать использования этого метода.
        </p>
    </li>
    <li>
        <h4>
            req.query
        </h4>
        <p>
            Объект, содержащий параметры строки запроса (иногда называемые GET - параметрами) в виде пар «имя/значение».
        </p>
    </li>
    <li>
        <h4>
            req.body
        </h4>
        <p>
            Объект, содержащий параметры POST . Такое название он носит потому, что POST - параметры передаются в теле запроса, а не
            в URL, как параметры строки запро- са. Чтобы получить доступ к req.body , вам понадобится промежуточное про-
            граммное обеспечение, которое умеет выполнять синтаксический разбор типа содержимого тела.
        </p>
    </li>
    <li>
        <h4>
            req.route
        </h4>
        <p>
            Информация о текущем совпавшем маршруте. Полезна главным образом для отладки маршрутизации. req.cookies/req.signedCookies
            Объекты, содержащие значения куки-файлов, передаваемые от клиента.
        </p>
    </li>
    <li>
        <h4>
            req.headers
        </h4>
        <p>
            Заголовки запроса, полученные от клиента.
        </p>
    </li>
    <li>
        <h4>
            req.accepts([types])
        </h4>
        <p>
            Удобный метод для принятия решения о том, должен ли клиент прини- мать данный тип или типы (необязательный параметр types
            может быть одиночным типом MIME, например application/json , разделенным запятыми списком или массивом). Этот
            метод обычно интересен тем, кто пишет публич- ные API; он предполагает, что браузеры всегда по умолчанию принимают
            HTML.
        </p>
    </li>
    <li>
        <h4>
            req.ip
        </h4>
        <p>
            IP-адрес клиента.
        </p>
    </li>
    <li>
        <h4>
            req.path
        </h4>
        <p>
            Путь запроса (без протокола, хоста, порта или строки запроса).
        </p>
    </li>
    <li>
        <h4>
            req.host
        </h4>
        <p>
            Удобный метод, возвращающий переданное клиентом имя хоста. Эта информа- ция может быть подделана и не должна использоваться
            из соображений безопас- ности.
        </p>
    </li>
    <li>
        <h4>
            req.xhr
        </h4>
        <p>
            Удобное свойство, возвращающее true , если запрос порожден вызовом AJAX.
        </p>
    </li>
    <li>
        <h4>
            req.protocol
        </h4>
        <p>
            Протокол, использованный при совершении данного запроса (в нашем случае это будет или http , или https ).
        </p>
    </li>
    <li>
        <h4>
            req.secure
        </h4>
        <p>
            Удобное свойство, возвращающее true , если соединение является безопасным. Эквивалентно req.protocol==='https' .
        </p>
    </li>
    <li>
        <h4>
            req.url/req.originalUrl
        </h4>
        <p>
            Небольшая неточность в наименовании — эти свойства возвращают путь и стро- ку запроса (они не включают протокол, хост или
            порт). req.url может быть переписан для нужд внутренней маршрутизации, но req.originalUrl разработан так, чтобы
            всегда хранить исходный путь и строку запроса.
        </p>
    </li>
    <li>
        <h4>
            req.acceptedLanguages
        </h4>
        <p>
            Удобный метод, возвращающий массив (естественных) языков, которые предпоч­ тительны клиенту. Эта информация получается путем
            анализа заголовка запроса.
        </p>
    </li>
</ol>

<h3>Response obj</h3>
<ol>
    <li>
        <h4>
            res.status(code)
        </h4>
        <p>
            Устанавливает код состояния HTTP. По умолчанию в Express код состояния — 200 («OK»), так что вам придется применять этот
            метод для возвращения состояния 404 («Не найдено»), или 500 («Ошибка сервера»), или любого другого кода состояния,
            который вы хотите использовать. Для перенаправле- ний (коды состояния 301, 302, 303 и 307) предпочтительнее применять
            метод redirect .
        </p>
    </li>
    <li>
        <h4>
            res.set(name, value)
        </h4>
        <p>
            Устанавливает заголовок ответа. Вряд ли в обычных условиях вы будете делать это вручную.
        </p>
    </li>
    <li>
        <h4>
            res.cookie(name, value, [options]), res.clearCookie(name, [options])
        </h4>
        <p>
            Устанавливает или очищает куки-файлы, которые будут храниться на клиенте. Для этого требуется поддержка промежуточного ПО.
        </p>
    </li>
    <li>
        <h4>
            res.redirect([status], url)
        </h4>
        <p>
            Выполняет перенаправление браузера. Код перенаправления по умолчанию — 302 («Найдено»). В целом вам лучше минимизировать
            перенаправления, за исключением случая окончательного перемещения страницы, когда следует использовать код 301
            («Перемещено навсегда»).
        </p>
    </li>
    <li>
        <h4>
            res.send(body), res.send(status, body)
        </h4>
        <p>
            Отправляет ответ клиенту с необязательным кодом состояния. По умолчанию в Express используется тип содержимого text/html
            , так что, если вы хотите изменить его на text/plain , например, необходимо вызвать res.set('Content-Type', 'text/
            plain') перед вызовом res.send . Если тело — объект или массив, вместо этого ответ будет отправлен в виде JSON
            (c установленным соответствующим типом содержимого), хотя, если вы хотите отправить JSON, я рекомендую делать
            это явным образом путем вызова res.json .
        </p>
    </li>
    <li>
        <h4>
            res.json(json), res.json(status, json)
        </h4>
        <p>
            Отправляет JSON клиенту с необязательным кодом состояния.
        </p>
    </li>
    <li>
        <h4>
            res.jsonp(json), res.jsonp(status, json)
        </h4>
        <p>
            Отправляет JSONP клиенту с необязательным кодом состояния.
        </p>
    </li>
    <li>
        <h4>
            res.type(type)
        </h4>
        <p>
            Удобный метод для установки заголовка Content-Type . Практически эквивален- тен res.set('Content-Type', type) , за исключением
            того, что он также будет пытать- ся установить соответствие расширений файлов типам данных Интернета, если вы
            укажете строку без косой черты. Например, Content-Type в случае res.type('txt') будет text/plain . Есть области
            применения, где эта функциональность может быть полезна (например, автоматическая выдача различных мультимедийных
            файлов), но в целом вам лучше избегать этого, предпочитая явным образом устанавливать правильный тип данных Интернета.
        </p>
    </li>
    <li>
        <h4>
            res.format(object)
        </h4>
        <p>
            Этот метод позволяет вам отправлять разнообразное содержимое в зависимости от заголовка Accept запроса. Он в основном используется
            в различных API . Вот очень простой пример: res.format({'text/plain': 'Привет!', 'text/html': '
            <b>Привет!</b>'}) .
        </p>
    </li>
    <li>
        <h4>
            res.attachment([filename]), res.download(path, [filename], [callback])
        </h4>
        <p>
            Оба этих метода устанавливают заголовок ответа Content-Disposition в значение attachment ; это указывает браузеру загружать
            содержимое вместо отображе- ния его в браузере. Вы можете задать filename в качестве подсказки браузеру. С помощью
            res.download можете задать файл для скачивания, в то время как res.attachment просто устанавливает заголовок
            и вам все еще нужно будет от- править контент клиенту.
        </p>
    </li>
    <li>
        <h4>
            res.sendFile(path, [options], [callback])
        </h4>
        <p>
            Этот метод читает файл, заданный параметром path , и отправляет его содержи- мое клиенту. Этот метод редко оказывается нужен
            — проще использовать про- межуточное ПО static и разместить файлы, которые вы хотите сделать доступ- ными клиенту,
            в каталог public . Однако, если вы хотите выдать другой ресурс с того же URL в зависимости от какого-либо условия,
            этот метод может ока- заться полезен.
        </p>
    </li>
    <li>
        <h4>
            res.links(links)
        </h4>
        <p>
            Задает заголовок ответа Links . Это узкоспециализированный заголовок, редко используемый в большинстве приложений.
        </p>
    </li>
    <li>
        <h4>
            res.locals, res.render(view, [locals], callback)
        </h4>
        <p>
            res.locals — объект, содержащий контекст по умолчанию для визуализации представлений. res.render визуализирует представление,
            используя указанный в настройках шаблонизатор (не путайте параметр locals в res.render с res.locals : он перекрывает
            контекст в res.locals , но неперекрытый контекст по-прежнему будет доступен). Обратите внимание на то, что res.render
            по умолчанию будет приводить к коду состояния ответа 200; используйте res.status для указания других кодов состояния.
            Визуализация представлений будет рассмотрена де- тальнее далее.
        </p>
    </li>
</ol>
